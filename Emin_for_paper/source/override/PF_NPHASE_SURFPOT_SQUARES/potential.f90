MODULE potential

  use global_variables
  implicit none
  

  ! Functions to override
  logical, parameter :: run_init = .true.
  logical, parameter :: perturb_coordinates_override = .true.

!-----------Declare model globals here-----------!

  !Simulation parameters 
  INTEGER :: GRIDX, GRIDY, GRIDZ, N_PHASE, N_NODES
  DOUBLE PRECISION, ALLOCATABLE :: COORDSG(:,:), WEIGHT(:), SURFWEIGHT(:), TENS(:,:), S(:,:), VOLUME(:), CONSTRAINTS(:,:), SB(:)
  DOUBLE PRECISION, ALLOCATABLE :: WETENERGY(:), SK(:,:), K44, K(:,:), CONF_POT(:,:), POT_SIGN(:,:)
  DOUBLE PRECISION :: GRIDSIZE, V0, CVOL, CONF_STRENGTH
  INTEGER, ALLOCATABLE :: NODESTATE(:), NEIGHBS(:,:), PAIRSTATE(:,:), GSQCASE(:,:), PHASESWITCH(:)
  LOGICAL  :: XSWITCH, YSWITCH, ZSWITCH, XMIRROR, YMIRROR, ZMIRROR 
  DOUBLE PRECISION :: INT_STRENGTH
  INTEGER :: POT_ITER
  INTEGER :: NPOSTX, NPOSTY, WIDTHX, WIDTHY, TOPEXX, TOPEXY, HEIGHT1, HEIGHT2, LIPX, LIPY, LIPZ
  DOUBLE PRECISION :: FORCE(3)=0.0
  DOUBLE PRECISION :: LAMBDA, ALPHA, A,B

!------------------------------------------------!


CONTAINS

!---------------------------------------------------------------------------------------------
! Wrappers
!---------------------------------------------------------------------------------------------
  !Wrapper for initialise system
  subroutine init()
    write(*,*) "InitWetting"
    call INITIALISE()
    write(*,*) "InitWetting end"
  end subroutine

  !Wrapper for computing the energy and gradient
  subroutine calc_energy_gradient()
    implicit none
    call COMPUTE_ENERGY_GRADIENT(X, G, E, .true.)
  end subroutine

  !Wrapper for perturbing the coordinates
  subroutine perturb_coordinates()
    IMPLICIT NONE
  end subroutine perturb_coordinates
!---------------------------------------------------------------------------------------------


!---------------------------------------------------------------------------------------------
! 1) Initialise the system
!---------------------------------------------------------------------------------------------
SUBROUTINE INITIALISE()
IMPLICIT NONE
INTEGER :: J4, J5, IP, IPP

!Define the number of nodes
N_NODES=GRIDX*GRIDY*GRIDZ

!Alter switches if necessary
IF (GRIDX==1) THEN
	XSWITCH=.FALSE.
ELSE
	XSWITCH=.TRUE.
ENDIF

IF (GRIDY==1) THEN
	YSWITCH=.FALSE.
ELSE
	YSWITCH=.TRUE.
ENDIF

IF (GRIDZ==1) THEN
	ZSWITCH=.FALSE.
ELSE
	ZSWITCH=.TRUE.
ENDIF

!1.1) Allocate arrays
ALLOCATE(COORDSG(N_NODES,N_PHASE),NODESTATE(N_NODES), NEIGHBS(N_NODES,6), PAIRSTATE(N_NODES,6))
ALLOCATE(WEIGHT(N_NODES), SURFWEIGHT(N_NODES),GSQCASE(N_NODES,3))
ALLOCATE(VOLUME(N_PHASE),SB(N_PHASE),SK(N_PHASE-1,N_PHASE-1),K(N_PHASE,N_PHASE))
ALLOCATE(CONSTRAINTS(N_PHASE,3),PHASESWITCH(N_PHASE),WETENERGY(N_PHASE))
ALLOCATE(S(N_PHASE-1,N_PHASE-1),TENS(N_PHASE,N_PHASE))
ALLOCATE(CONF_POT(N_NODES,N_PHASE),POT_SIGN(N_NODES,N_PHASE))
COORDSG=0.0
NODESTATE=0
NEIGHBS=0
PAIRSTATE=0
WEIGHT=1.0
SURFWEIGHT=0.0
S=0.0
GSQCASE=0.0
VOLUME=0.0
CONSTRAINTS=0.0
PHASESWITCH=0
POT_ITER=0
CONF_POT=0.0
POT_SIGN=0.0


!1.2) Make the surface and assign all node values
CALL ASSIGN_NODES()

!Read in the surface tensions
OPEN(1,FILE='data/gamma.in')
DO J4=1,N_PHASE
	DO J5=1,N_PHASE
		READ(1,*) TENS(J4,J5)    !where is the 'tens' from?
	ENDDO
ENDDO
CLOSE(1)

OPEN(1,FILE='data/A.in')
READ(1,*) A
READ(1,*) B
CLOSE(1)


!Read in constraints
OPEN(1,FILE='data/constraints.in')
DO J4=1,N_PHASE
	READ(1,*) CONSTRAINTS(J4,:)
ENDDO
CLOSE(1)

!Read in phaseswitch
OPEN(1,FILE='data/phaseswitch.in')
READ(1,*) PHASESWITCH
CLOSE(1)

!Read in the wetting potentials
OPEN(1,FILE='data/wetenergy.in')
READ(1,*) WETENERGY
CLOSE(1)

!Read in the bodyforce
!OPEN(1,FILE='data/force.in')
!READ(1,*) FORCE(1)
!READ(1,*) FORCE(2)
!READ(1,*) FORCE(3)
!CLOSE(1)

!Make the spreading parameters
OPEN(1,FILE='data/gamma.in')
DO J4=1,N_PHASE-1
	DO J5=1,N_PHASE-1
		S(J4,J5)=TENS(J4,J5)-(TENS(J4,N_PHASE)+TENS(J5,N_PHASE))
	ENDDO
ENDDO
CLOSE(1)
DO J4=1,N_PHASE-1
	S(J4,J4)=2*TENS(J4,N_PHASE)
	DO J5=1,N_PHASE-1
		IF (J5 .NE. J4) THEN
			S(J4,J4)=S(J4,J4)+S(J4,J5)
		ENDIF
	ENDDO
ENDDO
DO J4=1,N_PHASE-1
	SK(J4,J4)=3.0/ALPHA*S(J4,J4)-K44  ! K44 = 0.0 in data.f90
	DO J5=1,N_PHASE-1
		IF (J5 .NE. J4) THEN
			SK(J4,J5)=-3.0/ALPHA*S(J4,J5)-K44
		ENDIF		
	ENDDO
ENDDO

DO J4=1,N_PHASE
	IP=MOD(J4+1,N_PHASE)
	IF (IP==0) IP=4
	IPP=MOD(J4+2,N_PHASE)
	IF (IPP==0) IPP=4
	!PRINT *, J4, IP, IPP
	SB(J4)=TENS(IP,IPP)-(TENS(J4,IP)+TENS(J4,IPP))
	
	IF (J4==1) THEN
		SB(J4)=TENS(3,4)-(TENS(1,3)+TENS(1,4))
	ENDIF
	
ENDDO

K(:,:)=0.0   
K(1,2)=TENS(1,2)+TENS(1,3)+TENS(1,4)+TENS(2,3)+TENS(2,4)-4*TENS(3,4)+2.5*B
K(1,3)=TENS(1,2)+TENS(1,3)+TENS(1,4)+TENS(2,3)-4*TENS(2,4)+TENS(3,4)-2.5*B
K(1,4)=TENS(1,2)+TENS(1,3)+TENS(1,4)-4*TENS(2,3)+TENS(2,4)+TENS(3,4)-2.5*A-2.5*B

K(2,3)=TENS(1,2)+TENS(1,3)-4*TENS(1,4)+TENS(2,3)+TENS(2,4)+TENS(3,4)
K(2,4)=TENS(1,2)-4*TENS(1,3)+TENS(1,4)+TENS(2,3)+TENS(2,4)+TENS(3,4)+2.5*A

K(3,4)=-4*TENS(1,2)+TENS(1,3)+TENS(1,4)+TENS(2,3)+TENS(2,4)+TENS(3,4)-2.5*A


K(2,1)=K(1,2)
K(3,1)=K(1,3)
K(4,1)=K(1,4)
K(3,2)=K(2,3)
K(4,2)=K(2,4)
K(4,3)=K(3,4)
	
K=K*0.3/ALPHA
	
!SB(1)=TENS(2,3)-(TENS(1,3)+TENS(1,2))
!SB(2)=TENS(1,3)-(TENS(1,2)+TENS(2,3))
END SUBROUTINE INITIALISE
!---------------------------------------------------------------------------------------------



!---------------------------------------------------------------------------------------------
! Function to compute the gradient-squared 
!---------------------------------------------------------------------------------------------
DOUBLE PRECISION FUNCTION GRADSQUARED(CI, CIP, CIM)
IMPLICIT NONE
DOUBLE PRECISION, INTENT(IN) :: CI, CIM, CIP

	GRADSQUARED=0.5*( (CIP-CI)**2 + (CI-CIM)**2 )/GRIDSIZE**2

END FUNCTION GRADSQUARED
!---------------------------------------------------------------------------------------------


!---------------------------------------------------------------------------------------------
! Function to compute the derivative of the gradient-squared 
!---------------------------------------------------------------------------------------------
DOUBLE PRECISION FUNCTION DGRADSQUARED(CI, CIP, CIM, WI, WIP, WIM)
IMPLICIT NONE
DOUBLE PRECISION, INTENT(IN) :: CI, CIM, CIP, WI, WIP, WIM

	DGRADSQUARED=( 2*CI-CIP-CIM )*WI
	DGRADSQUARED=DGRADSQUARED+( CI-CIP )*WIP
	DGRADSQUARED=DGRADSQUARED+( CI-CIM )*WIM
	DGRADSQUARED=DGRADSQUARED/GRIDSIZE**2 ! /(2*GRIDSIZE**2) ???
	
END FUNCTION DGRADSQUARED
!---------------------------------------------------------------------------------------------



!---------------------------------------------------------------------------------------------
! 2) Compute the energy and gradient
!---------------------------------------------------------------------------------------------
SUBROUTINE COMPUTE_ENERGY_GRADIENT(COORDS, V, E, GTEST)
IMPLICIT NONE
DOUBLE PRECISION :: COORDS(N), V(N), E
LOGICAL :: GTEST
INTEGER :: CUR,J4

E=0
V=0

!Unpack the coords
COORDSG(:,:)=0.0
DO CUR=1,N_NODES
	DO J4=1,N_PHASE-1
		COORDSG(CUR,J4)=COORDS((CUR-1)*(N_PHASE-1)+J4)
		!Enforce the density=1 constraint
		COORDSG(CUR,N_PHASE)=COORDSG(CUR,N_PHASE)-COORDS((CUR-1)*(N_PHASE-1)+J4)
	ENDDO
ENDDO
COORDSG(:,N_PHASE)=COORDSG(:,N_PHASE)+1

!2.1) Compute the energy
CALL COMPUTE_ENERGY(E)

!2.2) Compute the gradient
CALL COMPUTE_GRADIENT(V)

!Test the gradinet against finite difference
!CALL TEST_GRADIENT(V)

  IF (MOD(POT_ITER,100)==0) THEN
  	OPEN(1,FILE='coords.step')
  	WRITE(1,'(F20.10)') COORDS
  	CLOSE(1)
  ENDIF
  POT_ITER=POT_ITER+1

END SUBROUTINE COMPUTE_ENERGY_GRADIENT
!---------------------------------------------------------------------------------------------



!---------------------------------------------------------------------------------------------
! 2.1) Compute the energy
!---------------------------------------------------------------------------------------------
SUBROUTINE COMPUTE_ENERGY(E)
IMPLICIT NONE
INTEGER :: CUR, J4, NEIGHBP, NEIGHBM, J1, J2, J3, J5, J6
DOUBLE PRECISION :: E, EBULK, ESURF, EGRADSQ, GRADSQ, RHO, ERHO, EVOL, EINT, EFORCE, ECONF
DOUBLE PRECISION :: GRADSQI, GRADSQJ, GRADSQIJ, CIPLUSCJ
LOGICAL :: TESTT=.TRUE.

E=0.0
EBULK=0.0
EGRADSQ=0.0
ESURF=0.0
ERHO=0.0
EVOL=0.0
EINT=0.0
VOLUME=0.0
EFORCE=0.0
ECONF=0.0

!2.1.1) Bulk energy
DO CUR=1,N_NODES
	IF (NODESTATE(CUR)>=0) THEN

		DO J4=1,N_PHASE-1
			DO J5=J4+1,N_PHASE
				CIPLUSCJ=COORDSG(CUR,J4)+COORDSG(CUR,J5)
			
				EBULK=EBULK+K(J4,J5)*WEIGHT(CUR)*( &
				& COORDSG(CUR,J4)**2*(1-COORDSG(CUR,J4))**2&
				&+COORDSG(CUR,J5)**2*(1-COORDSG(CUR,J5))**2&
				&+CIPLUSCJ**2*(1-CIPLUSCJ)**2 )
			ENDDO
		ENDDO


		EBULK=EBULK+A*(COORDSG(CUR,1)**2*COORDSG(CUR,3)**2&
		&	  +0.5*COORDSG(CUR,1)**2*COORDSG(CUR,4)**2&
		&	  +0.5*COORDSG(CUR,2)**2*COORDSG(CUR,4)**2&
		&	  +0.5*COORDSG(CUR,3)**2*COORDSG(CUR,4)**2)*WEIGHT(CUR)	
		
		EBULK=EBULK+B*(COORDSG(CUR,3)**2*COORDSG(CUR,4)**2&
		&	  +0.5*COORDSG(CUR,1)**2*COORDSG(CUR,2)**2&
		&	  +0.5*COORDSG(CUR,1)**2*COORDSG(CUR,3)**2&
		&	  +0.5*COORDSG(CUR,1)**2*COORDSG(CUR,4)**2)*WEIGHT(CUR)
		
		DO J4=1,N_PHASE-2
			DO J5=J4+1,N_PHASE-1
				DO J6=J5+1,N_PHASE
					EBULK=EBULK+LAMBDA*WEIGHT(CUR)*COORDSG(CUR,J4)**2*COORDSG(CUR,J5)**2*COORDSG(CUR,J6)**2
				ENDDO
			ENDDO
		ENDDO

	ENDIF	
ENDDO

		
!2.1.2) Gradient energy
!X-Gradients
IF (XSWITCH) THEN
	DO CUR=1,N_NODES
		IF (NODESTATE(CUR)>=0) THEN
			NEIGHBP=NEIGHBS(CUR,1)
			NEIGHBM=NEIGHBS(CUR,2)
			
			SELECT CASE(GSQCASE(CUR,1))
			CASE (0)
				!Compute the self-gradient terms
				DO J4=1,N_PHASE-1
					GRADSQ=GRADSQUARED(COORDSG(CUR,J4),COORDSG(NEIGHBP,J4),COORDSG(NEIGHBM,J4))
					EGRADSQ=EGRADSQ+S(J4,J4)*GRADSQ*WEIGHT(CUR)
				ENDDO
				
				!Compute the cross-gradient terms
				DO J4=1,N_PHASE-2
					DO J5=J4+1,N_PHASE-1
						GRADSQIJ=GRADSQUARED(COORDSG(CUR,J4)+COORDSG(CUR,J5),COORDSG(NEIGHBP,J4)&
						&+COORDSG(NEIGHBP,J5),COORDSG(NEIGHBM,J4)+COORDSG(NEIGHBM,J5))
						EGRADSQ=EGRADSQ-S(J4,J5)*GRADSQIJ*WEIGHT(CUR)
					ENDDO
				ENDDO	
												
			END SELECT
		ENDIF
	ENDDO	
ENDIF


!Y-Gradients
IF (YSWITCH) THEN
	DO CUR=1,N_NODES
		IF (NODESTATE(CUR)>=0) THEN
			NEIGHBP=NEIGHBS(CUR,3)
			NEIGHBM=NEIGHBS(CUR,4)
			
			SELECT CASE(GSQCASE(CUR,2))
			CASE (0)
				!Compute the self-gradient terms
				DO J4=1,N_PHASE-1
					GRADSQ=GRADSQUARED(COORDSG(CUR,J4),COORDSG(NEIGHBP,J4),COORDSG(NEIGHBM,J4))
					EGRADSQ=EGRADSQ+S(J4,J4)*GRADSQ*WEIGHT(CUR)
				ENDDO
				
				!Compute the cross-gradient terms
				DO J4=1,N_PHASE-2
					DO J5=J4+1,N_PHASE-1
						GRADSQIJ=GRADSQUARED(COORDSG(CUR,J4)+COORDSG(CUR,J5),COORDSG(NEIGHBP,J4)&
						&+COORDSG(NEIGHBP,J5),COORDSG(NEIGHBM,J4)+COORDSG(NEIGHBM,J5))
						EGRADSQ=EGRADSQ-S(J4,J5)*GRADSQIJ*WEIGHT(CUR)
					ENDDO
				ENDDO
										
			END SELECT
		ENDIF
	ENDDO	
ENDIF


!Z-Gradients
IF (ZSWITCH) THEN
	DO CUR=1,N_NODES
		IF (NODESTATE(CUR)>=0) THEN
			NEIGHBP=NEIGHBS(CUR,5)
			NEIGHBM=NEIGHBS(CUR,6)
			
			SELECT CASE(GSQCASE(CUR,3))
			CASE (0)
				!Compute the self-gradient terms
				DO J4=1,N_PHASE-1
					GRADSQ=GRADSQUARED(COORDSG(CUR,J4),COORDSG(NEIGHBP,J4),COORDSG(NEIGHBM,J4))
					EGRADSQ=EGRADSQ+S(J4,J4)*GRADSQ*WEIGHT(CUR)
				ENDDO
				
				!Compute the cross-gradient terms
				DO J4=1,N_PHASE-2
					DO J5=J4+1,N_PHASE-1
						GRADSQIJ=GRADSQUARED(COORDSG(CUR,J4)+COORDSG(CUR,J5),COORDSG(NEIGHBP,J4)&
						&+COORDSG(NEIGHBP,J5),COORDSG(NEIGHBM,J4)+COORDSG(NEIGHBM,J5))
						EGRADSQ=EGRADSQ-S(J4,J5)*GRADSQIJ*WEIGHT(CUR)
					ENDDO
				ENDDO
											
			END SELECT
		ENDIF
	ENDDO	
ENDIF



!2.1.3) Surface energy					
DO CUR=1,N_NODES
	IF (NODESTATE(CUR)==1) THEN
		DO J4=1,N_PHASE
			ESURF=ESURF+WETENERGY(J4)*(COORDSG(CUR,J4)**2/2.0-2.0/3.0*COORDSG(CUR,J4)**3+0.25*COORDSG(CUR,J4)**4)*SURFWEIGHT(CUR)
		ENDDO
	ENDIF
ENDDO


!Volume/pressure constraints
DO CUR=1,N_NODES
	IF (NODESTATE(CUR)>=0) THEN
		DO J4=1,N_PHASE
			VOLUME(J4)=VOLUME(J4)+COORDSG(CUR,J4)*WEIGHT(CUR)
		ENDDO
	ENDIF
ENDDO
DO J4=1,N_PHASE
	IF (NINT(CONSTRAINTS(J4,1))==1) THEN
	!Volume constraint
		EVOL = EVOL+CONSTRAINTS(J4,3)*(CONSTRAINTS(J4,2)-VOLUME(J4))**2
	ELSEIF (NINT(CONSTRAINTS(J4,1))==2) THEN
	!Pressure constraint
		EVOL = EVOL-CONSTRAINTS(J4,2)*VOLUME(J4)
	ENDIF
ENDDO


! Make the body force potential at each node in the system
  DO J1=1,GRIDX
  	DO J2=1,GRIDY
  		DO J3=1,GRIDZ
  			CUR=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3
  			EFORCE=EFORCE+FORCE(1)*J1*COORDSG(CUR,1)
  			EFORCE=EFORCE+FORCE(2)*J2*COORDSG(CUR,1) 
  			EFORCE=EFORCE+FORCE(3)*J3*COORDSG(CUR,1)  							
  		ENDDO
  	ENDDO
  ENDDO


! Implement the confining potential at each node for each phase
DO CUR=1,N_NODES
	DO J4=1,N_PHASE
		ECONF=ECONF+CONF_POT(CUR,J4)*WEIGHT(CUR)*( &
		&(2*POT_SIGN(CUR,J4)-1)*(COORDSG(CUR,J4)-POT_SIGN(CUR,J4))**3*&
		&(3*COORDSG(CUR,J4)-4+5*POT_SIGN(CUR,J4)) )
		
	ENDDO
ENDDO

E = EBULK+1.5*EGRADSQ*ALPHA+ESURF+ERHO+EVOL+EFORCE+ECONF

END SUBROUTINE COMPUTE_ENERGY
!---------------------------------------------------------------------------------------------


!---------------------------------------------------------------------------------------------
! 2.2) Compute the gradient
!---------------------------------------------------------------------------------------------
SUBROUTINE COMPUTE_GRADIENT(V)
IMPLICIT NONE
DOUBLE PRECISION :: V(N), GRAD(N_NODES,N_PHASE), RHO, CIPLUSCJ, DGRADSQI, DGRADSQIJ, PREFACB, PREFACI
INTEGER :: CUR, J4, NEIGHBM, NEIGHBP, J1, J2, J3, J5, J6
LOGICAL :: TESTT=.TRUE.

V=0.0
GRAD=0.0
PREFACB=1.0
PREFACI=1.5*ALPHA


!2.1.1) Bulk gradient
DO CUR=1,N_NODES
	IF (NODESTATE(CUR)>=0) THEN
		
		DO J4=1,N_PHASE
			DO J5=J4+1,N_PHASE
				CIPLUSCJ=COORDSG(CUR,J4)+COORDSG(CUR,J5)
			
				GRAD(CUR,J4)=GRAD(CUR,J4)+K(J4,J5)*WEIGHT(CUR)*( &
				& 2*COORDSG(CUR,J4)*(1-COORDSG(CUR,J4))*(1-2*COORDSG(CUR,J4))&
				&+2*CIPLUSCJ*(1-CIPLUSCJ)*(1-2*CIPLUSCJ) )
			ENDDO
			
			DO J5=1,J4-1
				CIPLUSCJ=COORDSG(CUR,J4)+COORDSG(CUR,J5)
			
				GRAD(CUR,J4)=GRAD(CUR,J4)+K(J5,J4)*WEIGHT(CUR)*( &
				& 2*COORDSG(CUR,J4)*(1-COORDSG(CUR,J4))*(1-2*COORDSG(CUR,J4))&
				&+2*CIPLUSCJ*(1-CIPLUSCJ)*(1-2*CIPLUSCJ) )
			ENDDO			
			
		ENDDO
		
		GRAD(CUR,1)=GRAD(CUR,1)+A*(2*COORDSG(CUR,1)*COORDSG(CUR,3)**2&
		&	                    +COORDSG(CUR,1)*COORDSG(CUR,4)**2)*WEIGHT(CUR)
		GRAD(CUR,2)=GRAD(CUR,2)+A*(COORDSG(CUR,2)*COORDSG(CUR,4)**2)*WEIGHT(CUR)		
		GRAD(CUR,3)=GRAD(CUR,3)+A*(2*COORDSG(CUR,3)*COORDSG(CUR,1)**2&
		&	                     +COORDSG(CUR,3)*COORDSG(CUR,4)**2)*WEIGHT(CUR)
		GRAD(CUR,4)=GRAD(CUR,4)+A*(COORDSG(CUR,4)*COORDSG(CUR,1)**2&
		&	                  +COORDSG(CUR,4)*COORDSG(CUR,2)**2&		
		&	                  +COORDSG(CUR,4)*COORDSG(CUR,3)**2)*WEIGHT(CUR)		
						
		GRAD(CUR,1)=GRAD(CUR,1)+B*(COORDSG(CUR,1)*COORDSG(CUR,2)**2&
		&	                  +COORDSG(CUR,1)*COORDSG(CUR,3)**2&		
		&	                  +COORDSG(CUR,1)*COORDSG(CUR,4)**2)*WEIGHT(CUR)
		GRAD(CUR,2)=GRAD(CUR,2)+B*(COORDSG(CUR,2)*COORDSG(CUR,1)**2)*WEIGHT(CUR)		
		GRAD(CUR,3)=GRAD(CUR,3)+B*(2*COORDSG(CUR,3)*COORDSG(CUR,4)**2&
		&	                     +COORDSG(CUR,3)*COORDSG(CUR,1)**2)*WEIGHT(CUR)				
		GRAD(CUR,4)=GRAD(CUR,4)+B*(2*COORDSG(CUR,4)*COORDSG(CUR,3)**2&
		&	                    +COORDSG(CUR,4)*COORDSG(CUR,1)**2)*WEIGHT(CUR)
		

		DO J4=1,N_PHASE-2
			DO J5=J4+1,N_PHASE-1
				DO J6=J5+1,N_PHASE
					GRAD(CUR,J4)=GRAD(CUR,J4)+2*LAMBDA*WEIGHT(CUR)*COORDSG(CUR,J4)*COORDSG(CUR,J5)**2*COORDSG(CUR,J6)**2
					GRAD(CUR,J5)=GRAD(CUR,J5)+2*LAMBDA*WEIGHT(CUR)**2*COORDSG(CUR,J4)**2*COORDSG(CUR,J5)*COORDSG(CUR,J6)**2
					GRAD(CUR,J6)=GRAD(CUR,J6)+2*LAMBDA*WEIGHT(CUR)**2*COORDSG(CUR,J4)**2*COORDSG(CUR,J5)**2*COORDSG(CUR,J6)
				ENDDO
			ENDDO
		ENDDO		
		
	ENDIF	
ENDDO



!2.1.2) Gradient gradient
!X-Gradients
IF (XSWITCH) THEN
	DO CUR=1,N_NODES
		IF (NODESTATE(CUR)>=0) THEN
			NEIGHBP=NEIGHBS(CUR,1)
			NEIGHBM=NEIGHBS(CUR,2)	
			SELECT CASE(GSQCASE(CUR,1))
			CASE (0)
				DO J4=1,N_PHASE-1
					!Self-term
					DGRADSQI=DGRADSQUARED(COORDSG(CUR,J4), COORDSG(NEIGHBP,J4), COORDSG(NEIGHBM,J4), &
					&WEIGHT(CUR), WEIGHT(NEIGHBP), WEIGHT(NEIGHBM))

					GRAD(CUR,J4)=GRAD(CUR,J4)+PREFACI*S(J4,J4)*DGRADSQI
					
					!Cross term
					DO J5=J4+1,N_PHASE-1
						DGRADSQIJ=DGRADSQUARED(COORDSG(CUR,J4)+COORDSG(CUR,J5),COORDSG(NEIGHBP,J4)+COORDSG(NEIGHBP,J5),&
						&COORDSG(NEIGHBM,J4)+COORDSG(NEIGHBM,J5),WEIGHT(CUR), WEIGHT(NEIGHBP), WEIGHT(NEIGHBM))
					
						GRAD(CUR,J4)=GRAD(CUR,J4)-PREFACI*S(J4,J5)*DGRADSQIJ
					ENDDO					
						
					!Cross term
					DO J5=1,J4-1
						DGRADSQIJ=DGRADSQUARED(COORDSG(CUR,J4)+COORDSG(CUR,J5),COORDSG(NEIGHBP,J4)+COORDSG(NEIGHBP,J5),&
						&COORDSG(NEIGHBM,J4)+COORDSG(NEIGHBM,J5),WEIGHT(CUR), WEIGHT(NEIGHBP), WEIGHT(NEIGHBM))
					
						GRAD(CUR,J4)=GRAD(CUR,J4)-PREFACI*S(J5,J4)*DGRADSQIJ
					ENDDO				
					
				ENDDO	

			END SELECT
		ENDIF
	ENDDO	
ENDIF


!Y-Gradients
IF (YSWITCH) THEN
	DO CUR=1,N_NODES
		IF (NODESTATE(CUR)>=0) THEN
			NEIGHBP=NEIGHBS(CUR,3)
			NEIGHBM=NEIGHBS(CUR,4)	
			SELECT CASE(GSQCASE(CUR,2))
			CASE (0)
				DO J4=1,N_PHASE-1
					!Self-term
					DGRADSQI=DGRADSQUARED(COORDSG(CUR,J4), COORDSG(NEIGHBP,J4), COORDSG(NEIGHBM,J4), &
					&WEIGHT(CUR), WEIGHT(NEIGHBP), WEIGHT(NEIGHBM))

					GRAD(CUR,J4)=GRAD(CUR,J4)+PREFACI*S(J4,J4)*DGRADSQI
					
					!Cross term
					DO J5=J4+1,N_PHASE-1
						DGRADSQIJ=DGRADSQUARED(COORDSG(CUR,J4)+COORDSG(CUR,J5),COORDSG(NEIGHBP,J4)+COORDSG(NEIGHBP,J5),&
						&COORDSG(NEIGHBM,J4)+COORDSG(NEIGHBM,J5),WEIGHT(CUR), WEIGHT(NEIGHBP), WEIGHT(NEIGHBM))
					
						GRAD(CUR,J4)=GRAD(CUR,J4)-PREFACI*S(J4,J5)*DGRADSQIJ
					ENDDO					
						
					!Cross term
					DO J5=1,J4-1
						DGRADSQIJ=DGRADSQUARED(COORDSG(CUR,J4)+COORDSG(CUR,J5),COORDSG(NEIGHBP,J4)+COORDSG(NEIGHBP,J5),&
						&COORDSG(NEIGHBM,J4)+COORDSG(NEIGHBM,J5),WEIGHT(CUR), WEIGHT(NEIGHBP), WEIGHT(NEIGHBM))
					
						GRAD(CUR,J4)=GRAD(CUR,J4)-PREFACI*S(J5,J4)*DGRADSQIJ
					ENDDO				
					
				ENDDO

			END SELECT
		ENDIF
	ENDDO	
ENDIF

!Z-Gradients
IF (ZSWITCH) THEN
	DO CUR=1,N_NODES
		IF (NODESTATE(CUR)>=0) THEN
			NEIGHBP=NEIGHBS(CUR,5)
			NEIGHBM=NEIGHBS(CUR,6)	
			SELECT CASE(GSQCASE(CUR,3))
			CASE (0)
				DO J4=1,N_PHASE-1
					!Self-term
					DGRADSQI=DGRADSQUARED(COORDSG(CUR,J4), COORDSG(NEIGHBP,J4), COORDSG(NEIGHBM,J4), &
					&WEIGHT(CUR), WEIGHT(NEIGHBP), WEIGHT(NEIGHBM))

					GRAD(CUR,J4)=GRAD(CUR,J4)+PREFACI*S(J4,J4)*DGRADSQI
					
					!Cross term
					DO J5=J4+1,N_PHASE-1
						DGRADSQIJ=DGRADSQUARED(COORDSG(CUR,J4)+COORDSG(CUR,J5),COORDSG(NEIGHBP,J4)+COORDSG(NEIGHBP,J5),&
						&COORDSG(NEIGHBM,J4)+COORDSG(NEIGHBM,J5),WEIGHT(CUR), WEIGHT(NEIGHBP), WEIGHT(NEIGHBM))
					
						GRAD(CUR,J4)=GRAD(CUR,J4)-PREFACI*S(J4,J5)*DGRADSQIJ
					ENDDO					
						
					!Cross term
					DO J5=1,J4-1
						DGRADSQIJ=DGRADSQUARED(COORDSG(CUR,J4)+COORDSG(CUR,J5),COORDSG(NEIGHBP,J4)+COORDSG(NEIGHBP,J5),&
						&COORDSG(NEIGHBM,J4)+COORDSG(NEIGHBM,J5),WEIGHT(CUR), WEIGHT(NEIGHBP), WEIGHT(NEIGHBM))
					
						GRAD(CUR,J4)=GRAD(CUR,J4)-PREFACI*S(J5,J4)*DGRADSQIJ
					ENDDO				
					
				ENDDO	

			END SELECT
		ENDIF
	ENDDO	
ENDIF




!2.1.3) Surface gradients					
DO CUR=1,N_NODES
	IF (NODESTATE(CUR)==1) THEN
		DO J4=1,N_PHASE
			GRAD(CUR,J4)=GRAD(CUR,J4)+WETENERGY(J4)*(COORDSG(CUR,J4)-2.0*COORDSG(CUR,J4)**2+COORDSG(CUR,J4)**3)*SURFWEIGHT(CUR)
		ENDDO
	ENDIF
ENDDO


!Volume/pressure constraints
DO J4=1,N_PHASE
	IF (NINT(CONSTRAINTS(J4,1))==1) THEN
	!Volume constraint
		DO CUR=1,N_NODES
			IF (NODESTATE(CUR)>=0) THEN
				GRAD(CUR,J4)=GRAD(CUR,J4)-2*CONSTRAINTS(J4,3)*WEIGHT(CUR)*(CONSTRAINTS(J4,2)-VOLUME(J4))
			ENDIF
		ENDDO
	ELSEIF (NINT(CONSTRAINTS(J4,1))==2) THEN
	!Pressure constraint
		DO CUR=1,N_NODES
			IF (NODESTATE(CUR)>=0) THEN
				GRAD(CUR,J4)=GRAD(CUR,J4)-CONSTRAINTS(J4,2)*WEIGHT(CUR)
			ENDIF
		ENDDO	
	ENDIF
ENDDO

! Make the body force potential at each node in the system
  DO J1=1,GRIDX
  	DO J2=1,GRIDY
  		DO J3=1,GRIDZ
  			CUR=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3
  			GRAD(CUR,1)=GRAD(CUR,1)+FORCE(1)*J1+FORCE(2)*J2+FORCE(3)*J3			
  		ENDDO
  	ENDDO
  ENDDO

! Implement the confining potential at each node for each phase
DO CUR=1,N_NODES
	DO J4=1,N_PHASE
		GRAD(CUR,J4)=GRAD(CUR,J4)+12.0*CONF_POT(CUR,J4)*WEIGHT(CUR)*( &
		&(2*POT_SIGN(CUR,J4)-1)*(COORDSG(CUR,J4)-POT_SIGN(CUR,J4))**2*&
		&(COORDSG(CUR,J4)-1+POT_SIGN(CUR,J4)) )
		
	ENDDO
ENDDO


!Finally reshape GRAD back to the 1D array V
DO CUR=1,N_NODES
	DO J4=1,N_PHASE-1

		IF (PHASESWITCH(J4)==1) THEN
			!The second term in this expression comes from enforcing the total density = 1
			V((CUR-1)*(N_PHASE-1)+J4)=GRAD(CUR,J4)-GRAD(CUR,N_PHASE)
		ELSE
			V((CUR-1)*(N_PHASE-1)+J4)=0.0
		ENDIF
	ENDDO
ENDDO


END SUBROUTINE COMPUTE_GRADIENT
!---------------------------------------------------------------------------------------------



!---------------------------------------------------------------------------------------------
! 1.2) Make the surface and assign all node values
!---------------------------------------------------------------------------------------------
SUBROUTINE ASSIGN_NODES()
IMPLICIT NONE
INTEGER :: J1,J2,J3,J4,CUR, SURFSUM, PASS, SOLIDSUM, P1, P2, XSTART, XSTOP, YSTART, YSTOP
INTEGER :: CURXPYPZP,CURXPYPZ0,CURXPYPZM,CURXPY0ZP,CURXPY0Z0,CURXPY0ZM,CURXPYMZP,CURXPYMZ0,CURXPYMZM &
&,CURX0YPZP,CURX0YPZ0,CURX0YPZM,CURX0Y0ZP,CURX0Y0Z0,CURX0Y0ZM,CURX0YMZP,CURX0YMZ0,CURX0YMZM &
&,CURXMYPZP,CURXMYPZ0,CURXMYPZM,CURXMY0ZP,CURXMY0Z0,CURXMY0ZM,CURXMYMZP,CURXMYMZ0,CURXMYMZM
INTEGER :: NODESTATE0(N_NODES), PERIOD_X, PERIOD_Y

NODESTATE0=NODESTATE

!1.2.1.2) Now automatically surround the solid nodes with surface nodes (pass 1), calculate the node properties (pass 2), and neighbour properties (pass3)
DO PASS=1,3
DO J1=1,GRIDX
	DO J2=1,GRIDY
		DO J3=1,GRIDZ
			!Define the neighbours in each direction (obeying periodic boundary conditions in the first instance)
			CUR=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3

			CURXPYPZP=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+MOD(J3,GRIDZ)+1
			CURXPYPZ0=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+J3
			CURXPYPZM=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURXPY0ZP=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(J2-1)*GRIDZ+MOD(J3,GRIDZ)+1
			CURXPY0Z0=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3
			CURXPY0ZM=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(J2-1)*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURXPYMZP=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+MOD(J3,GRIDZ)+1
			CURXPYMZ0=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+J3
			CURXPYMZM=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURX0YPZP=(J1-1)*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+MOD(J3,GRIDZ)+1
			CURX0YPZ0=(J1-1)*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+J3
			CURX0YPZM=(J1-1)*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURX0Y0ZP=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+MOD(J3,GRIDZ)+1
			CURX0Y0Z0=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3
			CURX0Y0ZM=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURX0YMZP=(J1-1)*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+MOD(J3,GRIDZ)+1
			CURX0YMZ0=(J1-1)*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+J3
			CURX0YMZM=(J1-1)*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURXMYPZP=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+MOD(J3,GRIDZ)+1
			CURXMYPZ0=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+J3
			CURXMYPZM=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURXMY0ZP=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+MOD(J3,GRIDZ)+1
			CURXMY0Z0=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3
			CURXMY0ZM=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURXMYMZP=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+MOD(J3,GRIDZ)+1
			CURXMYMZ0=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+J3
			CURXMYMZM=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			! Mirror symmetries (all we need to do is update the cardinal directions)
			
			! Mirror symmetry at the J1=1 and J1=GRIDX boundaries
			IF (XMIRROR) THEN
				IF (J1==1) THEN
					CURXMYPZP=CURX0YPZP
					CURXMYPZ0=CURX0YPZ0
					CURXMYPZM=CURX0YPZM

					CURXMY0ZP=CURX0Y0ZP
					CURXMY0Z0=CUR
					CURXMY0ZM=CURX0Y0ZM

					CURXMYMZP=CURX0YMZP
					CURXMYMZ0=CURX0YMZ0
					CURXMYMZM=CURX0YMZM
											
				ELSEIF (J1==GRIDX) THEN
					CURXPYPZP=CURX0YPZP
					CURXPYPZ0=CURX0YPZ0
					CURXPYPZM=CURX0YPZM

					CURXPY0ZP=CURX0Y0ZP
					CURXPY0Z0=CUR
					CURXPY0ZM=CURX0Y0ZM

					CURXPYMZP=CURX0YMZP
					CURXPYMZ0=CURX0YMZ0
					CURXPYMZM=CURX0YMZM
		
				ENDIF
			ENDIF
			
			! Mirror symmetry at the J2=1 and J2=GRIDY boundaries
			IF (YMIRROR) THEN
				IF (J2==1) THEN
					CURXPYMZP=CURXPY0ZP
					CURXPYMZ0=CURXPY0Z0
					CURXPYMZM=CURXPY0ZM
						
					CURX0YMZP=CURX0Y0ZP
					CURX0YMZ0=CUR
					CURX0YMZM=CURX0Y0ZM
						
					CURXMYMZP=CURXMY0ZP
					CURXMYMZ0=CURXMY0Z0
					CURXMYMZM=CURXMY0ZM

					
				ELSEIF (J2==GRIDY) THEN
					CURXPYPZP=CURXPY0ZP
					CURXPYPZ0=CURXPY0Z0
					CURXPYPZM=CURXPY0ZM
						
					CURX0YPZP=CURX0Y0ZP
					CURX0YPZ0=CUR
					CURX0YPZM=CURX0Y0ZM
						
					CURXMYPZP=CURXMY0ZP
					CURXMYPZ0=CURXMY0Z0
					CURXMYPZM=CURXMY0ZM
		
				ENDIF
			ENDIF		
				
			! Mirror symmetry at the J3=1 and J3=GRIDZ boundaries
			IF (ZMIRROR) THEN
				IF (J3==1) THEN
				
					CURXPYPZM=CURXPYPZ0
					CURXPY0ZM=CURXPY0Z0
					CURXPYMZM=CURXPYMZ0
						
					CURX0YPZM=CURX0YPZ0
					CURX0Y0ZM=CUR
					CURX0YMZM=CURX0YMZ0
						
					CURXMYPZM=CURXMYPZ0
					CURXMY0ZM=CURXMY0Z0
					CURXMYMZM=CURXMYMZ0

				ELSEIF (J3==GRIDZ) THEN
				
					CURXPYPZP=CURXPYPZ0
					CURXPY0ZP=CURXPY0Z0
					CURXPYMZP=CURXPYMZ0
						
					CURX0YPZP=CURX0YPZ0
					CURX0Y0ZP=CUR
					CURX0YMZP=CURX0YMZ0
						
					CURXMYPZP=CURXMYPZ0
					CURXMY0ZP=CURXMY0Z0
					CURXMYMZP=CURXMYMZ0		
				ENDIF
			ENDIF	

			!!!		开始删除		
			IF (PASS==1) THEN
				!Calculate the sum of proximal solid nodes
				SURFSUM=0
				SURFSUM=NODESTATE0(CURXPYPZP)+NODESTATE0(CURXPYPZ0)+NODESTATE0(CURXPYPZM)&
&					+NODESTATE0(CURXPY0ZP)+NODESTATE0(CURXPY0Z0)+NODESTATE0(CURXPY0ZM)&
&					+NODESTATE0(CURXPYMZP)+NODESTATE0(CURXPYMZ0)+NODESTATE0(CURXPYMZM)&
&					+NODESTATE0(CURX0YPZP)+NODESTATE0(CURX0YPZ0)+NODESTATE0(CURX0YPZM)&
&					+NODESTATE0(CURX0Y0ZP)+NODESTATE0(CURX0Y0Z0)+NODESTATE0(CURX0Y0ZM)&
&					+NODESTATE0(CURX0YMZP)+NODESTATE0(CURX0YMZ0)+NODESTATE0(CURX0YMZM)&
&					+NODESTATE0(CURXMYPZP)+NODESTATE0(CURXMYPZ0)+NODESTATE0(CURXMYPZM)&
&					+NODESTATE0(CURXMY0ZP)+NODESTATE0(CURXMY0Z0)+NODESTATE0(CURXMY0ZM)&
&					+NODESTATE0(CURXMYMZP)+NODESTATE0(CURXMYMZ0)+NODESTATE0(CURXMYMZM)
				SURFSUM=-SURFSUM

				!Define surface node properties
				IF (SURFSUM>0) THEN
					!Indicate the surface node in NODESTATE
					IF (NODESTATE(CUR)>=0) THEN
						NODESTATE(CUR)=1
					ENDIF
				ENDIF
			
				!Update neighbour list
				NEIGHBS(CUR,:)=(/CURXPY0Z0,CURXMY0Z0,CURX0YPZ0,CURX0YMZ0,CURX0Y0ZP,CURX0Y0ZM/)

			ELSEIF (PASS==2) THEN

				IF (NODESTATE(CUR)==1) THEN
					IF ( (XSWITCH).AND.(YSWITCH).AND.(ZSWITCH) ) THEN
					!3D
						!Count the number of surface nodes in cardinal directions
						SURFSUM=0
						IF (NODESTATE(CURXPY0Z0)==1) SURFSUM=SURFSUM+1
						IF (NODESTATE(CURXMY0Z0)==1) SURFSUM=SURFSUM+1
						IF (NODESTATE(CURX0YPZ0)==1) SURFSUM=SURFSUM+1
						IF (NODESTATE(CURX0YMZ0)==1) SURFSUM=SURFSUM+1
						IF (NODESTATE(CURX0Y0ZP)==1) SURFSUM=SURFSUM+1
						IF (NODESTATE(CURX0Y0ZM)==1) SURFSUM=SURFSUM+1

						!Count the number of surface nodes in cardinal directions
						SOLIDSUM=0
						IF (NODESTATE(CURXPY0Z0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURXMY0Z0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0YPZ0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0YMZ0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0Y0ZP)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0Y0ZM)==-1) SOLIDSUM=SOLIDSUM+1

						!Compute the surface node properties
						IF ( (SURFSUM==3) .AND. (SOLIDSUM==0) ) THEN
							WEIGHT(CUR)=0.875
							SURFWEIGHT(CUR)=0.75
						ELSEIF ( (SURFSUM==4) .AND. (SOLIDSUM==0) ) THEN
							WEIGHT(CUR)=0.75
							SURFWEIGHT(CUR)=1.0
						ELSEIF ( (SURFSUM==5) .AND. (SOLIDSUM==0) ) THEN
							WEIGHT(CUR)=0.625
							SURFWEIGHT(CUR)=1.25
						ELSEIF ( (SURFSUM==4) .AND. (SOLIDSUM==1) ) THEN
							WEIGHT(CUR)=0.5
							SURFWEIGHT(CUR)=1.0
						ELSEIF ( (SURFSUM==5) .AND. (SOLIDSUM==1) ) THEN
							WEIGHT(CUR)=0.375
							SURFWEIGHT(CUR)=1.25
						ELSEIF ( (SURFSUM==4) .AND. (SOLIDSUM==2) ) THEN
							WEIGHT(CUR)=0.25
							SURFWEIGHT(CUR)=1.0
						ELSEIF ( (SURFSUM==3) .AND. (SOLIDSUM==3) ) THEN
							WEIGHT(CUR)=0.125
							SURFWEIGHT(CUR)=0.75
						ELSE
							PRINT *, 'ASSIGN_NODES> CASE NOT DEFINED AT NODE', CUR, 'J1, J2, J3 =',J1,J2,J3, 'SURFSUM', SURFSUM, 'SOLIDSUM', SOLIDSUM
						ENDIF

					ELSE
					!2D
						!Count the number of surface nodes in cardinal directions
						SOLIDSUM=0
						IF (NODESTATE(CURXPY0Z0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURXMY0Z0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0YPZ0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0YMZ0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0Y0ZP)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0Y0ZM)==-1) SOLIDSUM=SOLIDSUM+1

						!Compute the surface node properties
						IF (SOLIDSUM==0) THEN
							WEIGHT(CUR)=0.75
							SURFWEIGHT(CUR)=1.0
						ELSEIF (SOLIDSUM==1) THEN
							WEIGHT(CUR)=0.5
							SURFWEIGHT(CUR)=1.0
						ELSEIF (SOLIDSUM==2) THEN
							WEIGHT(CUR)=0.25
							SURFWEIGHT(CUR)=1.0
						ELSE
							PRINT *, 'ASSIGN_NODES> CASE NOT DEFINED AT NODE', CUR, 'J1, J2, J3 =',J1,J2,J3, 'SOLIDSUM', SOLIDSUM
						ENDIF
		
					ENDIF
				ENDIF				

			ELSEIF (PASS==3) THEN

				!Compute the pair properties between neighbours
				IF (NODESTATE(CUR)==0) THEN
					IF (NODESTATE(CURXPY0Z0)==1) THEN
						IF ( (WEIGHT(CURXPY0Z0)==0.625) .OR. (WEIGHT(CURXPY0Z0)==0.75) .OR. (WEIGHT(CURXPY0Z0)==0.875) ) THEN
							PAIRSTATE(CUR,1)=1
						ELSE
							PAIRSTATE(CUR,1)=2
						ENDIF
					ELSE
						PAIRSTATE(CUR,1)=1
					ENDIF

					IF (NODESTATE(CURXMY0Z0)==1) THEN
						IF ( (WEIGHT(CURXMY0Z0)==0.625) .OR. (WEIGHT(CURXMY0Z0)==0.75) .OR. (WEIGHT(CURXMY0Z0)==0.875) ) THEN
							PAIRSTATE(CUR,2)=1
						ELSE
							PAIRSTATE(CUR,2)=2
						ENDIF
					ELSE
						PAIRSTATE(CUR,2)=1
					ENDIF

					IF (NODESTATE(CURX0YPZ0)==1) THEN
						IF ( (WEIGHT(CURX0YPZ0)==0.625) .OR. (WEIGHT(CURX0YPZ0)==0.75) .OR. (WEIGHT(CURX0YPZ0)==0.875) ) THEN
							PAIRSTATE(CUR,3)=1
						ELSE
							PAIRSTATE(CUR,3)=2
						ENDIF
					ELSE
						PAIRSTATE(CUR,3)=1
					ENDIF
			
					IF (NODESTATE(CURX0YMZ0)==1) THEN
						IF ( (WEIGHT(CURX0YMZ0)==0.625) .OR. (WEIGHT(CURX0YMZ0)==0.75) .OR. (WEIGHT(CURX0YMZ0)==0.875) ) THEN
							PAIRSTATE(CUR,4)=1
						ELSE
							PAIRSTATE(CUR,4)=2
						ENDIF
					ELSE
						PAIRSTATE(CUR,4)=1
					ENDIF

					IF (NODESTATE(CURX0Y0ZP)==1) THEN
						IF ( (WEIGHT(CURX0Y0ZP)==0.625) .OR. (WEIGHT(CURX0Y0ZP)==0.75) .OR. (WEIGHT(CURX0Y0ZP)==0.875) ) THEN
							PAIRSTATE(CUR,5)=1
						ELSE
							PAIRSTATE(CUR,5)=2
						ENDIF
					ELSE
						PAIRSTATE(CUR,5)=1
					ENDIF

					IF (NODESTATE(CURX0Y0ZM)==1) THEN
						IF ( (WEIGHT(CURX0Y0ZM)==0.625) .OR. (WEIGHT(CURX0Y0ZM)==0.75) .OR. (WEIGHT(CURX0Y0ZM)==0.875) ) THEN
							PAIRSTATE(CUR,6)=1
						ELSE
							PAIRSTATE(CUR,6)=2
						ENDIF
					ELSE
						PAIRSTATE(CUR,6)=1
					ENDIF
				ELSEIF (NODESTATE(CUR)==1) THEN
					!Specific conditions for a neighboring surface normal facing back at the current node
					IF (WEIGHT(CURXPY0Z0)==0.125) THEN
						PAIRSTATE(CUR,1)=2
					ELSEIF ( (WEIGHT(CUR)==0.5) .AND. (WEIGHT(CURXPY0Z0)==0.25) ) THEN
						PAIRSTATE(CUR,1)=2
					ELSEIF ( (WEIGHT(CUR)==0.75) .AND. (WEIGHT(CURXPY0Z0)==0.375) ) THEN
						PAIRSTATE(CUR,1)=2
					ELSE
						!Not a corner
						PAIRSTATE(CUR,1)=1
					ENDIF

					IF (WEIGHT(CURXMY0Z0)==0.125) THEN
						PAIRSTATE(CUR,2)=2
					ELSEIF ( (WEIGHT(CUR)==0.5) .AND. (WEIGHT(CURXMY0Z0)==0.25) ) THEN
						PAIRSTATE(CUR,2)=2
					ELSEIF ( (WEIGHT(CUR)==0.75) .AND. (WEIGHT(CURXMY0Z0)==0.375) ) THEN
						PAIRSTATE(CUR,2)=2
					ELSE
						PAIRSTATE(CUR,2)=1
					ENDIF

					IF (WEIGHT(CURX0YPZ0)==0.125) THEN
						PAIRSTATE(CUR,3)=2
					ELSEIF ( (WEIGHT(CUR)==0.5) .AND. (WEIGHT(CURX0YPZ0)==0.25) ) THEN
						PAIRSTATE(CUR,3)=2
					ELSEIF ( (WEIGHT(CUR)==0.75) .AND. (WEIGHT(CURX0YPZ0)==0.375) ) THEN
						PAIRSTATE(CUR,3)=2
					ELSE
						PAIRSTATE(CUR,3)=1
					ENDIF

					IF (WEIGHT(CURX0YMZ0)==0.125) THEN
						PAIRSTATE(CUR,4)=2
					ELSEIF ( (WEIGHT(CUR)==0.5) .AND. (WEIGHT(CURX0YMZ0)==0.25) ) THEN
						PAIRSTATE(CUR,4)=2
					ELSEIF ( (WEIGHT(CUR)==0.75) .AND. (WEIGHT(CURX0YMZ0)==0.375) ) THEN
						PAIRSTATE(CUR,4)=2
					ELSE
						PAIRSTATE(CUR,4)=1
					ENDIF

					IF (WEIGHT(CURX0Y0ZP)==0.125) THEN
						PAIRSTATE(CUR,5)=2
					ELSEIF ( (WEIGHT(CUR)==0.5) .AND. (WEIGHT(CURX0Y0ZP)==0.25) ) THEN
						PAIRSTATE(CUR,5)=2
					ELSEIF ( (WEIGHT(CUR)==0.75) .AND. (WEIGHT(CURX0Y0ZP)==0.375) ) THEN
						PAIRSTATE(CUR,5)=2
					ELSE
						PAIRSTATE(CUR,5)=1
					ENDIF

					IF (WEIGHT(CURX0Y0ZM)==0.125) THEN
						PAIRSTATE(CUR,6)=2
					ELSEIF ( (WEIGHT(CUR)==0.5) .AND. (WEIGHT(CURX0Y0ZM)==0.25) ) THEN
						PAIRSTATE(CUR,6)=2
					ELSEIF ( (WEIGHT(CUR)==0.75) .AND. (WEIGHT(CURX0Y0ZM)==0.375) ) THEN
						PAIRSTATE(CUR,6)=2
					ELSE
						PAIRSTATE(CUR,6)=1
					ENDIF

				ENDIF


				!Fill the GSQCASE array
				IF (NODESTATE(CUR)==0) THEN
					GSQCASE(CUR,:)=0.0
				ELSEIF (NODESTATE(CUR)==1) THEN
					IF ( (NODESTATE(CURXPY0Z0)>=0) .AND. (NODESTATE(CURXMY0Z0)>=0) ) THEN
						GSQCASE(CUR,1)=0
					ELSEIF (NODESTATE(CURXPY0Z0)==-1) THEN
						GSQCASE(CUR,1)=-1
					ELSEIF (NODESTATE(CURXMY0Z0)==-1) THEN
						GSQCASE(CUR,1)=1
					ENDIF

					IF ( (NODESTATE(CURX0YPZ0)>=0) .AND. (NODESTATE(CURX0YMZ0)>=0) ) THEN
						GSQCASE(CUR,2)=0
					ELSEIF (NODESTATE(CURX0YPZ0)==-1) THEN
						GSQCASE(CUR,2)=-1
					ELSEIF (NODESTATE(CURX0YMZ0)==-1) THEN
						GSQCASE(CUR,2)=1
					ENDIF

					IF ( (NODESTATE(CURX0Y0ZP)>=0) .AND. (NODESTATE(CURX0Y0ZM)>=0) ) THEN
						GSQCASE(CUR,3)=0
					ELSEIF (NODESTATE(CURX0Y0ZP)==-1) THEN
						GSQCASE(CUR,3)=-1
					ELSEIF (NODESTATE(CURX0Y0ZM)==-1) THEN
						GSQCASE(CUR,3)=1
					ENDIF		
				ENDIF
							
			ENDIF
			!!! 停止删除
			
		ENDDO
	ENDDO
ENDDO
ENDDO


!Make the external potential
CONF_POT=0.0
POT_SIGN=0

PERIOD_X=INT(GRIDX/NPOSTX)
PERIOD_Y=INT(GRIDY/NPOSTY)

DO P1 = 1,NPOSTX
	DO P2 = 1,NPOSTY
		
		XSTART = 1
		YSTART = INT((P2-1)*PERIOD_Y+1 + (PERIOD_Y-WIDTHY)/2)
		XSTOP = INT(XSTART+WIDTHX/2)
		YSTOP = YSTART+WIDTHY
		
		
		DO J1 = 1,PERIOD_X
			DO J2 = (P2-1)*PERIOD_Y+1,P2*PERIOD_Y
				DO J3=1,HEIGHT1
					CUR=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3
					IF ( (J1<XSTOP) .AND. (J2>=YSTART) .AND. (J2<YSTOP)) THEN
						CONF_POT(CUR,2)=CONF_STRENGTH
						POT_SIGN(CUR,2)=0.5*(1+SIGN(1D0,CONF_POT(CUR,2)))
					ELSE
						CONF_POT(CUR,3)=CONF_STRENGTH
						POT_SIGN(CUR,3)=0.5*(1+SIGN(1D0,CONF_POT(CUR,3)))	
					ENDIF
					
					CONF_POT(CUR,1)=-CONF_STRENGTH
					POT_SIGN(CUR,1)=0.5*(1+SIGN(1D0,CONF_POT(CUR,1)))
					
				ENDDO
			ENDDO
		ENDDO					

	ENDDO
ENDDO



END SUBROUTINE ASSIGN_NODES
!---------------------------------------------------------------------------------------------


!---------------------------------------------------------------------------------------------------------------
!Test the gradient vs a finite difference approximation
SUBROUTINE TEST_GRADIENT(V)
IMPLICIT NONE
INTEGER :: CUR,J4
DOUBLE PRECISION :: DT, A_0, A_P, A_M, E_P, E_M, TEST_GRAD(N), GRAD_DIFF(N), V(N), A_0N, A_PN, A_MN

DT=0.00001

DO CUR=1,N_NODES
	DO J4=1,N_PHASE-1
		
		A_0 = COORDSG(CUR,J4)
		A_P = COORDSG(CUR,J4) + DT
		A_M = COORDSG(CUR,J4) - DT
		
		A_0N = COORDSG(CUR,N_PHASE)
		A_PN = COORDSG(CUR,N_PHASE) - DT
		A_MN = COORDSG(CUR,N_PHASE) + DT
		E=0.0

		COORDSG(CUR,J4) = A_P
		COORDSG(CUR,N_PHASE) = A_PN
		CALL COMPUTE_ENERGY(E)
		E_P=E

		COORDSG(CUR,J4)=A_M
		COORDSG(CUR,N_PHASE) = A_MN
		CALL COMPUTE_ENERGY(E)
		E_M=E

		TEST_GRAD((CUR-1)*(N_PHASE-1)+J4) = (E_P-E_M)/(2*DT)

		COORDSG(CUR,J4) = A_0
		COORDSG(CUR,N_PHASE) = A_0N

	
		PRINT *, CUR, J4, V((CUR-1)*(N_PHASE-1)+J4), TEST_GRAD((CUR-1)*(N_PHASE-1)+J4), &
		&V((CUR-1)*(N_PHASE-1)+J4)-TEST_GRAD((CUR-1)*(N_PHASE-1)+J4)
		IF (ABS(V((CUR-1)*(N_PHASE-1)+J4)-TEST_GRAD((CUR-1)*(N_PHASE-1)+J4))>=0.001) THEN
		 	STOP
		ENDIF

	ENDDO

ENDDO

GRAD_DIFF = V-TEST_GRAD
PRINT *, 'SUCCESS!', SUM(SQRT(GRAD_DIFF*GRAD_DIFF))

stop

OPEN(1,FILE='grad.diff')
WRITE(1,'(F20.10)') GRAD_DIFF
CLOSE(1)

OPEN(1,FILE='grad.orig')
WRITE(1,'(F20.10)') G
CLOSE(1)

OPEN(1,FILE='grad.test')
WRITE(1,'(F20.10)') TEST_GRAD
CLOSE(1)

END SUBROUTINE TEST_GRADIENT


END MODULE potential
