MODULE potential

  use global_variables
  implicit none
  

  ! Functions to override
  logical, parameter :: run_init = .true.
  logical, parameter :: perturb_coordinates_override = .true.

!-----------Declare model globals here-----------!

  !Simulation parameters 
  INTEGER :: GRIDX, GRIDY, GRIDZ, N_PHASE, N_NODES
  DOUBLE PRECISION, ALLOCATABLE :: COORDSG(:,:), WEIGHT(:), SURFWEIGHT(:), K(:), KP(:), VOLUME(:), CONSTRAINTS(:,:)
  DOUBLE PRECISION, ALLOCATABLE :: WETENERGY(:)
  DOUBLE PRECISION :: GRIDSIZE, CRHO, V0, CVOL
  INTEGER, ALLOCATABLE :: NODESTATE(:), NEIGHBS(:,:), PAIRSTATE(:,:), GSQCASE(:,:), PHASESWITCH(:)
  LOGICAL  :: XSWITCH, YSWITCH, ZSWITCH 

!------------------------------------------------!


CONTAINS

!---------------------------------------------------------------------------------------------
! Wrappers
!---------------------------------------------------------------------------------------------
  !Wrapper for initialise system
  subroutine init()
    write(*,*) "InitWetting"
    call INITIALISE()
    write(*,*) "InitWetting end"
  end subroutine

  !Wrapper for computing the energy and gradient
  subroutine calc_energy_gradient()
    implicit none
    call COMPUTE_ENERGY_GRADIENT(X, G, E, .true.)
  end subroutine

  !Wrapper for perturbing the coordinates
  subroutine perturb_coordinates()
    IMPLICIT NONE
  end subroutine perturb_coordinates
!---------------------------------------------------------------------------------------------


!---------------------------------------------------------------------------------------------
! 1) Initialise the system
!---------------------------------------------------------------------------------------------
SUBROUTINE INITIALISE()
IMPLICIT NONE
INTEGER :: J4

!Define the number of nodes
N_NODES=GRIDX*GRIDY*GRIDZ

!Alter switches if necessary
IF (GRIDX==1) THEN
	XSWITCH=.FALSE.
ELSE
	XSWITCH=.TRUE.
ENDIF

IF (GRIDY==1) THEN
	YSWITCH=.FALSE.
ELSE
	YSWITCH=.TRUE.
ENDIF

IF (GRIDZ==1) THEN
	ZSWITCH=.FALSE.
ELSE
	ZSWITCH=.TRUE.
ENDIF

!1.1) Allocate arrays
ALLOCATE(COORDSG(N_NODES,N_PHASE),NODESTATE(N_NODES), NEIGHBS(N_NODES,6), PAIRSTATE(N_NODES,6))
ALLOCATE(WEIGHT(N_NODES), SURFWEIGHT(N_NODES),GSQCASE(N_NODES,3))
ALLOCATE(K(N_PHASE),KP(N_PHASE),VOLUME(N_PHASE))
ALLOCATE(CONSTRAINTS(N_PHASE,3),PHASESWITCH(N_PHASE),WETENERGY(N_PHASE))
COORDSG=0.0
NODESTATE=0
NEIGHBS=0
PAIRSTATE=0
WEIGHT=1.0
SURFWEIGHT=0.0
K=0.0
KP=0.0
GSQCASE=0.0
VOLUME=0.0
CONSTRAINTS=0.0
PHASESWITCH=0

!1.2) Make the surface and assign all node values
CALL ASSIGN_NODES()

!Read in the K and KP
OPEN(1,FILE='data/K.in')
READ(1,*) K
CLOSE(1)

OPEN(1,FILE='data/KP.in')
READ(1,*) KP
CLOSE(1)

!Read in constraints
OPEN(1,FILE='data/constraints.in')
DO J4=1,N_PHASE
	READ(1,*) CONSTRAINTS(J4,:)
ENDDO
CLOSE(1)

!Read in phaseswitch
OPEN(1,FILE='data/phaseswitch.in')
READ(1,*) PHASESWITCH
CLOSE(1)

!Read in the wetting potentials
OPEN(1,FILE='data/wetenergy.in')
READ(1,*) WETENERGY
CLOSE(1)

END SUBROUTINE INITIALISE
!---------------------------------------------------------------------------------------------


!---------------------------------------------------------------------------------------------
! 2) Compute the energy and gradient
!---------------------------------------------------------------------------------------------
SUBROUTINE COMPUTE_ENERGY_GRADIENT(COORDS, V, E, GTEST)
IMPLICIT NONE
DOUBLE PRECISION :: COORDS(N), V(N), E
LOGICAL :: GTEST
INTEGER :: CUR,J4

!Unpack the coords
DO CUR=1,N_NODES
	DO J4=1,N_PHASE
		COORDSG(CUR,J4)=COORDS((CUR-1)*N_PHASE+J4)
	ENDDO
ENDDO



!2.1) Compute the energy
CALL COMPUTE_ENERGY(E)

!2.2) Compute the gradient
CALL COMPUTE_GRADIENT(V)

!Test the gradinet against finite difference
!CALL TEST_GRADIENT(V)

END SUBROUTINE COMPUTE_ENERGY_GRADIENT
!---------------------------------------------------------------------------------------------



!---------------------------------------------------------------------------------------------
! 2.1) Compute the energy
!---------------------------------------------------------------------------------------------
SUBROUTINE COMPUTE_ENERGY(E)
IMPLICIT NONE
INTEGER :: CUR, J4, NEIGHBP, NEIGHBM
DOUBLE PRECISION :: E, EBULK, ESURF, EGRADSQ, GRADSQ, RHO, ERHO, EVOL

E=0.0
EBULK=0.0
EGRADSQ=0.0
ESURF=0.0
ERHO=0.0
EVOL=0.0
VOLUME=0.0


!2.1.1) Bulk energy
DO CUR=1,N_NODES
	IF (NODESTATE(CUR)>=0) THEN
		DO J4=1,N_PHASE
			EBULK=EBULK+0.5*K(J4)*COORDSG(CUR,J4)**2*(1-COORDSG(CUR,J4))**2*WEIGHT(CUR)
		ENDDO
	ENDIF
ENDDO

		
!2.1.2) Gradient energy
!X-Gradients
IF (XSWITCH) THEN
	DO CUR=1,N_NODES
		IF (NODESTATE(CUR)>=0) THEN
			SELECT CASE(GSQCASE(CUR,1))
			CASE (0)
				DO J4=1,N_PHASE
					NEIGHBP=NEIGHBS(CUR,1)
					NEIGHBM=NEIGHBS(CUR,2)		
					GRADSQ=(COORDSG(NEIGHBP,J4)-COORDSG(CUR,J4))**2 + (COORDSG(CUR,J4)-COORDSG(NEIGHBM,J4))**2
					EGRADSQ=EGRADSQ+0.25*KP(J4)*GRADSQ*WEIGHT(CUR)/GRIDSIZE**2
				ENDDO
			CASE (1)
				DO J4=1,N_PHASE
					NEIGHBP=NEIGHBS(CUR,1)		
					GRADSQ=(COORDSG(NEIGHBP,J4)-COORDSG(CUR,J4))**2
					EGRADSQ=EGRADSQ+0.5*KP(J4)*GRADSQ*WEIGHT(CUR)/GRIDSIZE**2
				ENDDO
			CASE (-1)
				DO J4=1,N_PHASE
					NEIGHBM=NEIGHBS(CUR,2)		
					GRADSQ=(COORDSG(CUR,J4)-COORDSG(NEIGHBM,J4))**2
					EGRADSQ=EGRADSQ+0.5*KP(J4)*GRADSQ*WEIGHT(CUR)/GRIDSIZE**2
				ENDDO
			END SELECT
		ENDIF
	ENDDO	
ENDIF


!Y-Gradients
IF (YSWITCH) THEN
	DO CUR=1,N_NODES
		IF (NODESTATE(CUR)>=0) THEN
			SELECT CASE(GSQCASE(CUR,2))
			CASE (0)
				DO J4=1,N_PHASE
					NEIGHBP=NEIGHBS(CUR,3)
					NEIGHBM=NEIGHBS(CUR,4)		
					GRADSQ=(COORDSG(NEIGHBP,J4)-COORDSG(CUR,J4))**2 + (COORDSG(CUR,J4)-COORDSG(NEIGHBM,J4))**2
					EGRADSQ=EGRADSQ+0.25*KP(J4)*GRADSQ*WEIGHT(CUR)/GRIDSIZE**2
				ENDDO
			CASE (1)
				DO J4=1,N_PHASE
					NEIGHBP=NEIGHBS(CUR,3)		
					GRADSQ=(COORDSG(NEIGHBP,J4)-COORDSG(CUR,J4))**2
					EGRADSQ=EGRADSQ+0.5*KP(J4)*GRADSQ*WEIGHT(CUR)/GRIDSIZE**2
				ENDDO
			CASE (-1)
				DO J4=1,N_PHASE
					NEIGHBM=NEIGHBS(CUR,4)		
					GRADSQ=(COORDSG(CUR,J4)-COORDSG(NEIGHBM,J4))**2
					EGRADSQ=EGRADSQ+0.5*KP(J4)*GRADSQ*WEIGHT(CUR)/GRIDSIZE**2
				ENDDO
			END SELECT
		ENDIF
	ENDDO	
ENDIF


!Z-Gradients
IF (ZSWITCH) THEN
	DO CUR=1,N_NODES
		IF (NODESTATE(CUR)>=0) THEN
			SELECT CASE(GSQCASE(CUR,3))
			CASE (0)
				DO J4=1,N_PHASE
					NEIGHBP=NEIGHBS(CUR,5)
					NEIGHBM=NEIGHBS(CUR,6)		
					GRADSQ=(COORDSG(NEIGHBP,J4)-COORDSG(CUR,J4))**2 + (COORDSG(CUR,J4)-COORDSG(NEIGHBM,J4))**2
					EGRADSQ=EGRADSQ+0.25*KP(J4)*GRADSQ*WEIGHT(CUR)/GRIDSIZE**2
				ENDDO
			CASE (1)
				DO J4=1,N_PHASE
					NEIGHBP=NEIGHBS(CUR,5)		
					GRADSQ=(COORDSG(NEIGHBP,J4)-COORDSG(CUR,J4))**2
					EGRADSQ=EGRADSQ+0.5*KP(J4)*GRADSQ*WEIGHT(CUR)/GRIDSIZE**2
				ENDDO
			CASE (-1)
				DO J4=1,N_PHASE
					NEIGHBM=NEIGHBS(CUR,6)		
					GRADSQ=(COORDSG(CUR,J4)-COORDSG(NEIGHBM,J4))**2
					EGRADSQ=EGRADSQ+0.5*KP(J4)*GRADSQ*WEIGHT(CUR)/GRIDSIZE**2
				ENDDO
			END SELECT
		ENDIF
	ENDDO	
ENDIF



!2.1.3) Surface energy					
DO CUR=1,N_NODES
	IF (NODESTATE(CUR)==1) THEN
		DO J4=1,N_PHASE
			ESURF=ESURF+WETENERGY(J4)*(COORDSG(CUR,J4)**2/2.0-COORDSG(CUR,J4)**3/3.0)*SURFWEIGHT(CUR)
		ENDDO
	ENDIF
ENDDO


!Density constraint
DO CUR=1,N_NODES
	IF (NODESTATE(CUR)>=0) THEN
		RHO=SUM(COORDSG(CUR,:))
		ERHO=ERHO+CRHO*(1-RHO)**2
	ENDIF
ENDDO

!Volume/pressure constraints
DO CUR=1,N_NODES
	IF (NODESTATE(CUR)>=0) THEN
		DO J4=1,N_PHASE
			VOLUME(J4)=VOLUME(J4)+COORDSG(CUR,J4)*WEIGHT(CUR)
		ENDDO
	ENDIF
ENDDO
DO J4=1,N_PHASE
	IF (NINT(CONSTRAINTS(J4,1))==1) THEN
	!Volume constraint
		EVOL = EVOL+CONSTRAINTS(J4,3)*(CONSTRAINTS(J4,2)-VOLUME(J4))**2
	ELSEIF (NINT(CONSTRAINTS(J4,1))==2) THEN
	!Pressure constraint
		EVOL = EVOL-CONSTRAINTS(J4,2)*VOLUME(J4)
	ENDIF
ENDDO


E = EBULK+EGRADSQ+ESURF+ERHO+EVOL
!PRINT *, EBULK, EGRADSQ, ESURF, ERHO, EVOL
!STOP


!print *, E
END SUBROUTINE COMPUTE_ENERGY
!---------------------------------------------------------------------------------------------




!---------------------------------------------------------------------------------------------
! 2.2) Compute the gradient
!---------------------------------------------------------------------------------------------
SUBROUTINE COMPUTE_GRADIENT(V)
IMPLICIT NONE
DOUBLE PRECISION :: V(N), GRAD(N_NODES,N_PHASE), RHO
INTEGER :: CUR, J4, NEIGHBM, NEIGHBP

V=0.0
GRAD=0.0

!2.1.1) Bulk gradient
DO CUR=1,N_NODES
	IF (NODESTATE(CUR)>=0) THEN
		DO J4=1,N_PHASE
			GRAD(CUR,J4)=GRAD(CUR,J4)+K(J4)*COORDSG(CUR,J4)*(1-COORDSG(CUR,J4))*(1-2*COORDSG(CUR,J4))*WEIGHT(CUR)
		ENDDO
	ENDIF
ENDDO

!2.1.2) Gradient gradient
!X-Gradients
IF (XSWITCH) THEN
	DO CUR=1,N_NODES
		IF (NODESTATE(CUR)>=0) THEN
			SELECT CASE(GSQCASE(CUR,1))
			CASE (0)
				DO J4=1,N_PHASE
					NEIGHBP=NEIGHBS(CUR,1)
					NEIGHBM=NEIGHBS(CUR,2)	
			
					GRAD(CUR,J4)=GRAD(CUR,J4)+0.5*KP(J4)/GRIDSIZE**2*( 2*COORDSG(CUR,J4)-COORDSG(NEIGHBP,J4)-COORDSG(NEIGHBM,J4) )*WEIGHT(CUR)
					GRAD(CUR,J4)=GRAD(CUR,J4)+0.5*PAIRSTATE(CUR,1)*KP(J4)/GRIDSIZE**2*( COORDSG(CUR,J4)-COORDSG(NEIGHBP,J4) )*WEIGHT(NEIGHBP)
					GRAD(CUR,J4)=GRAD(CUR,J4)+0.5*PAIRSTATE(CUR,2)*KP(J4)/GRIDSIZE**2*( COORDSG(CUR,J4)-COORDSG(NEIGHBM,J4) )*WEIGHT(NEIGHBM)
			
				ENDDO
			CASE (1)
				DO J4=1,N_PHASE
					NEIGHBP=NEIGHBS(CUR,1)
			
					GRAD(CUR,J4)=GRAD(CUR,J4)+KP(J4)/GRIDSIZE**2*( COORDSG(CUR,J4)-COORDSG(NEIGHBP,J4) )*WEIGHT(CUR)
					GRAD(CUR,J4)=GRAD(CUR,J4)+0.5*PAIRSTATE(CUR,1)*KP(J4)/GRIDSIZE**2*( COORDSG(CUR,J4)-COORDSG(NEIGHBP,J4) )*WEIGHT(NEIGHBP)
				ENDDO
			CASE (-1)
				DO J4=1,N_PHASE
					NEIGHBM=NEIGHBS(CUR,2)
			
					GRAD(CUR,J4)=GRAD(CUR,J4)+KP(J4)/GRIDSIZE**2*( COORDSG(CUR,J4)-COORDSG(NEIGHBM,J4) )*WEIGHT(CUR)
					GRAD(CUR,J4)=GRAD(CUR,J4)+0.5*PAIRSTATE(CUR,2)*KP(J4)/GRIDSIZE**2*( COORDSG(CUR,J4)-COORDSG(NEIGHBM,J4) )*WEIGHT(NEIGHBM)
				ENDDO			

			END SELECT
		ENDIF
	ENDDO	
ENDIF

!Y-Gradients
IF (YSWITCH) THEN
	DO CUR=1,N_NODES
		IF (NODESTATE(CUR)>=0) THEN
			SELECT CASE(GSQCASE(CUR,2))
			CASE (0)
				DO J4=1,N_PHASE
					NEIGHBP=NEIGHBS(CUR,3)
					NEIGHBM=NEIGHBS(CUR,4)	
			
					GRAD(CUR,J4)=GRAD(CUR,J4)+0.5*KP(J4)/GRIDSIZE**2*( 2*COORDSG(CUR,J4)-COORDSG(NEIGHBP,J4)-COORDSG(NEIGHBM,J4) )*WEIGHT(CUR)
					GRAD(CUR,J4)=GRAD(CUR,J4)+0.5*PAIRSTATE(CUR,3)*KP(J4)/GRIDSIZE**2*( COORDSG(CUR,J4)-COORDSG(NEIGHBP,J4) )*WEIGHT(NEIGHBP)
					GRAD(CUR,J4)=GRAD(CUR,J4)+0.5*PAIRSTATE(CUR,4)*KP(J4)/GRIDSIZE**2*( COORDSG(CUR,J4)-COORDSG(NEIGHBM,J4) )*WEIGHT(NEIGHBM)
			
				ENDDO
			CASE (1)
				DO J4=1,N_PHASE
					NEIGHBP=NEIGHBS(CUR,3)
			
					GRAD(CUR,J4)=GRAD(CUR,J4)+KP(J4)/GRIDSIZE**2*( COORDSG(CUR,J4)-COORDSG(NEIGHBP,J4) )*WEIGHT(CUR)
					GRAD(CUR,J4)=GRAD(CUR,J4)+0.5*PAIRSTATE(CUR,3)*KP(J4)/GRIDSIZE**2*( COORDSG(CUR,J4)-COORDSG(NEIGHBP,J4) )*WEIGHT(NEIGHBP)
				ENDDO
			CASE (-1)
				DO J4=1,N_PHASE
					NEIGHBM=NEIGHBS(CUR,4)
			
					GRAD(CUR,J4)=GRAD(CUR,J4)+KP(J4)/GRIDSIZE**2*( COORDSG(CUR,J4)-COORDSG(NEIGHBM,J4) )*WEIGHT(CUR)
					GRAD(CUR,J4)=GRAD(CUR,J4)+0.5*PAIRSTATE(CUR,4)*KP(J4)/GRIDSIZE**2*( COORDSG(CUR,J4)-COORDSG(NEIGHBM,J4) )*WEIGHT(NEIGHBM)
				ENDDO			

			END SELECT
		ENDIF
	ENDDO	
ENDIF

!Z-Gradients
IF (ZSWITCH) THEN
	DO CUR=1,N_NODES
		IF (NODESTATE(CUR)>=0) THEN
			SELECT CASE(GSQCASE(CUR,3))
			CASE (0)
				DO J4=1,N_PHASE
					NEIGHBP=NEIGHBS(CUR,5)
					NEIGHBM=NEIGHBS(CUR,6)	
			
					GRAD(CUR,J4)=GRAD(CUR,J4)+0.5*KP(J4)/GRIDSIZE**2*( 2*COORDSG(CUR,J4)-COORDSG(NEIGHBP,J4)-COORDSG(NEIGHBM,J4) )*WEIGHT(CUR)
					GRAD(CUR,J4)=GRAD(CUR,J4)+0.5*PAIRSTATE(CUR,5)*KP(J4)/GRIDSIZE**2*( COORDSG(CUR,J4)-COORDSG(NEIGHBP,J4) )*WEIGHT(NEIGHBP)
					GRAD(CUR,J4)=GRAD(CUR,J4)+0.5*PAIRSTATE(CUR,6)*KP(J4)/GRIDSIZE**2*( COORDSG(CUR,J4)-COORDSG(NEIGHBM,J4) )*WEIGHT(NEIGHBM)
			
				ENDDO
			CASE (1)
				DO J4=1,N_PHASE
					NEIGHBP=NEIGHBS(CUR,5)
			
					GRAD(CUR,J4)=GRAD(CUR,J4)+KP(J4)/GRIDSIZE**2*( COORDSG(CUR,J4)-COORDSG(NEIGHBP,J4) )*WEIGHT(CUR)
					GRAD(CUR,J4)=GRAD(CUR,J4)+0.5*PAIRSTATE(CUR,5)*KP(J4)/GRIDSIZE**2*( COORDSG(CUR,J4)-COORDSG(NEIGHBP,J4) )*WEIGHT(NEIGHBP)
				ENDDO
			CASE (-1)
				DO J4=1,N_PHASE
					NEIGHBM=NEIGHBS(CUR,6)
			
					GRAD(CUR,J4)=GRAD(CUR,J4)+KP(J4)/GRIDSIZE**2*( COORDSG(CUR,J4)-COORDSG(NEIGHBM,J4) )*WEIGHT(CUR)
					GRAD(CUR,J4)=GRAD(CUR,J4)+0.5*PAIRSTATE(CUR,6)*KP(J4)/GRIDSIZE**2*( COORDSG(CUR,J4)-COORDSG(NEIGHBM,J4) )*WEIGHT(NEIGHBM)
				ENDDO			

			END SELECT
		ENDIF
	ENDDO	
ENDIF



!2.1.3) Surface gradients					
DO CUR=1,N_NODES
	IF (NODESTATE(CUR)==1) THEN
		DO J4=1,N_PHASE
			GRAD(CUR,J4)=GRAD(CUR,J4)+WETENERGY(J4)*(COORDSG(CUR,J4)-COORDSG(CUR,J4)**2)*SURFWEIGHT(CUR)
		ENDDO
	ENDIF
ENDDO



!Density constraint
DO CUR=1,N_NODES
	IF (NODESTATE(CUR)>=0) THEN
		RHO=SUM(COORDSG(CUR,:))
		GRAD(CUR,:)=GRAD(CUR,:)-2.0*CRHO*(1-RHO)
	ENDIF
ENDDO


!Volume/pressure constraints
DO J4=1,N_PHASE
	IF (NINT(CONSTRAINTS(J4,1))==1) THEN
	!Volume constraint
		DO CUR=1,N_NODES
			IF (NODESTATE(CUR)>=0) THEN
				GRAD(CUR,J4)=GRAD(CUR,J4)-2*CONSTRAINTS(J4,3)*WEIGHT(CUR)*(CONSTRAINTS(J4,2)-VOLUME(J4))
			ENDIF
		ENDDO
	ELSEIF (NINT(CONSTRAINTS(J4,1))==2) THEN
	!Pressure constraint
		DO CUR=1,N_NODES
			IF (NODESTATE(CUR)>=0) THEN
				GRAD(CUR,J4)=GRAD(CUR,J4)-CONSTRAINTS(J4,2)*WEIGHT(CUR)
			ENDIF
		ENDDO	
	ENDIF
ENDDO



!Finally reshape GRAD back to the 1D array V
DO CUR=1,N_NODES
	DO J4=1,N_PHASE
		IF (PHASESWITCH(J4)==1) THEN
			V((CUR-1)*N_PHASE+J4)=GRAD(CUR,J4)
		ELSE
			V((CUR-1)*N_PHASE+J4)=0.0
		ENDIF
	ENDDO
ENDDO




END SUBROUTINE COMPUTE_GRADIENT
!---------------------------------------------------------------------------------------------




!---------------------------------------------------------------------------------------------
! 1.2) Make the surface and assign all node values
!---------------------------------------------------------------------------------------------
SUBROUTINE ASSIGN_NODES()
IMPLICIT NONE
INTEGER :: J1,J2,J3,CUR, SURFSUM, PASS, SOLIDSUM
INTEGER :: CURXPYPZP,CURXPYPZ0,CURXPYPZM,CURXPY0ZP,CURXPY0Z0,CURXPY0ZM,CURXPYMZP,CURXPYMZ0,CURXPYMZM &
&,CURX0YPZP,CURX0YPZ0,CURX0YPZM,CURX0Y0ZP,CURX0Y0Z0,CURX0Y0ZM,CURX0YMZP,CURX0YMZ0,CURX0YMZM &
&,CURXMYPZP,CURXMYPZ0,CURXMYPZM,CURXMY0ZP,CURXMY0Z0,CURXMY0ZM,CURXMYMZP,CURXMYMZ0,CURXMYMZM
INTEGER :: NODESTATE0(N_NODES),NX

!1.2.1) Make the nodestate array
!1.2.1.1) Start by defining which nodes are solid nodes  - this can be changed depending on the surface
DO J1=1,GRIDX
	DO J2=1,GRIDY
		DO J3=1,GRIDZ
			CUR=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3

		ENDDO
	ENDDO
ENDDO
NODESTATE0=NODESTATE

!1.2.1.2) Now automatically surround the solid nodes with surface nodes (pass 1) and calculate the node properties (pass 2) 
DO PASS=1,2
DO J1=1,GRIDX
	DO J2=1,GRIDY
		DO J3=1,GRIDZ
			!Define the neighbours in each direction
			CUR=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3

			CURXPYPZP=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+MOD(J3,GRIDZ)+1
			CURXPYPZ0=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+J3
			CURXPYPZM=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURXPY0ZP=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(J2-1)*GRIDZ+MOD(J3,GRIDZ)+1
			CURXPY0Z0=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3
			CURXPY0ZM=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(J2-1)*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURXPYMZP=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+MOD(J3,GRIDZ)+1
			CURXPYMZ0=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+J3
			CURXPYMZM=(MOD(J1,GRIDX))*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURX0YPZP=(J1-1)*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+MOD(J3,GRIDZ)+1
			CURX0YPZ0=(J1-1)*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+J3
			CURX0YPZM=(J1-1)*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURX0Y0ZP=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+MOD(J3,GRIDZ)+1
			CURX0Y0Z0=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3
			CURX0Y0ZM=(J1-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURX0YMZP=(J1-1)*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+MOD(J3,GRIDZ)+1
			CURX0YMZ0=(J1-1)*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+J3
			CURX0YMZM=(J1-1)*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURXMYPZP=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+MOD(J3,GRIDZ)+1
			CURXMYPZ0=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+J3
			CURXMYPZM=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(MOD(J2,GRIDY))*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURXMY0ZP=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+MOD(J3,GRIDZ)+1
			CURXMY0Z0=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+J3
			CURXMY0ZM=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(J2-1)*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)

			CURXMYMZP=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+MOD(J3,GRIDZ)+1
			CURXMYMZ0=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+J3
			CURXMYMZM=(GRIDX+MOD(J1-GRIDX-1,GRIDX)-1)*GRIDY*GRIDZ+(GRIDY+MOD(J2-GRIDY-1,GRIDY)-1)*GRIDZ+GRIDZ+MOD(J3-GRIDZ-1,GRIDZ)


			
			IF (PASS==1) THEN
				!Calculate the sum of proximal solid nodes
				SURFSUM=0
				SURFSUM=NODESTATE0(CURXPYPZP)+NODESTATE0(CURXPYPZ0)+NODESTATE0(CURXPYPZM)&
&					+NODESTATE0(CURXPY0ZP)+NODESTATE0(CURXPY0Z0)+NODESTATE0(CURXPY0ZM)&
&					+NODESTATE0(CURXPYMZP)+NODESTATE0(CURXPYMZ0)+NODESTATE0(CURXPYMZM)&
&					+NODESTATE0(CURX0YPZP)+NODESTATE0(CURX0YPZ0)+NODESTATE0(CURX0YPZM)&
&					+NODESTATE0(CURX0Y0ZP)+NODESTATE0(CURX0Y0Z0)+NODESTATE0(CURX0Y0ZM)&
&					+NODESTATE0(CURX0YMZP)+NODESTATE0(CURX0YMZ0)+NODESTATE0(CURX0YMZM)&
&					+NODESTATE0(CURXMYPZP)+NODESTATE0(CURXMYPZ0)+NODESTATE0(CURXMYPZM)&
&					+NODESTATE0(CURXMY0ZP)+NODESTATE0(CURXMY0Z0)+NODESTATE0(CURXMY0ZM)&
&					+NODESTATE0(CURXMYMZP)+NODESTATE0(CURXMYMZ0)+NODESTATE0(CURXMYMZM)
				SURFSUM=-SURFSUM

				!Define surface node properties
				IF (SURFSUM>0) THEN
					!Indicate the surface node in NODESTATE
					IF (NODESTATE(CUR)>=0) THEN
						NODESTATE(CUR)=1
					ENDIF
				ENDIF
			
				!Update neighbour list
				NEIGHBS(CUR,:)=(/CURXPY0Z0,CURXMY0Z0,CURX0YPZ0,CURX0YMZ0,CURX0Y0ZP,CURX0Y0ZM/)

			ELSEIF (PASS==2) THEN

				IF (NODESTATE(CUR)==1) THEN
					IF ( (XSWITCH).AND.(YSWITCH).AND.(ZSWITCH) ) THEN
					!3D
						!Count the number of surface nodes in cardinal directions
						SURFSUM=0
						IF (NODESTATE(CURXPY0Z0)==1) SURFSUM=SURFSUM+1
						IF (NODESTATE(CURXMY0Z0)==1) SURFSUM=SURFSUM+1
						IF (NODESTATE(CURX0YPZ0)==1) SURFSUM=SURFSUM+1
						IF (NODESTATE(CURX0YMZ0)==1) SURFSUM=SURFSUM+1
						IF (NODESTATE(CURX0Y0ZP)==1) SURFSUM=SURFSUM+1
						IF (NODESTATE(CURX0Y0ZM)==1) SURFSUM=SURFSUM+1

						!Count the number of surface nodes in cardinal directions
						SOLIDSUM=0
						IF (NODESTATE(CURXPY0Z0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURXMY0Z0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0YPZ0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0YMZ0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0Y0ZP)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0Y0ZM)==-1) SOLIDSUM=SOLIDSUM+1

						!Compute the surface node properties
						IF ( (SURFSUM==3) .AND. (SOLIDSUM==0) ) THEN
							WEIGHT(CUR)=0.875
							SURFWEIGHT(CUR)=0.75
						ELSEIF ( (SURFSUM==4) .AND. (SOLIDSUM==0) ) THEN
							WEIGHT(CUR)=0.75
							SURFWEIGHT(CUR)=1.0
						ELSEIF ( (SURFSUM==5) .AND. (SOLIDSUM==0) ) THEN
							WEIGHT(CUR)=0.625
							SURFWEIGHT(CUR)=1.25
						ELSEIF ( (SURFSUM==4) .AND. (SOLIDSUM==1) ) THEN
							WEIGHT(CUR)=0.5
							SURFWEIGHT(CUR)=1.0
						ELSEIF ( (SURFSUM==5) .AND. (SOLIDSUM==1) ) THEN
							WEIGHT(CUR)=0.375
							SURFWEIGHT(CUR)=1.25
						ELSEIF ( (SURFSUM==4) .AND. (SOLIDSUM==2) ) THEN
							WEIGHT(CUR)=0.25
							SURFWEIGHT(CUR)=1.0
						ELSEIF ( (SURFSUM==3) .AND. (SOLIDSUM==3) ) THEN
							WEIGHT(CUR)=0.125
							SURFWEIGHT(CUR)=0.75
						ELSE
							PRINT *, 'ASSIGN_NODES> CASE NOT DEFINED AT NODE', CUR, 'J1, J2, J3 =',J1,J2,J3, 'SURFSUM', SURFSUM, 'SOLIDSUM', SOLIDSUM
						ENDIF

					ELSE
					!2D
						!Count the number of surface nodes in cardinal directions
						SOLIDSUM=0
						IF (NODESTATE(CURXPY0Z0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURXMY0Z0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0YPZ0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0YMZ0)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0Y0ZP)==-1) SOLIDSUM=SOLIDSUM+1
						IF (NODESTATE(CURX0Y0ZM)==-1) SOLIDSUM=SOLIDSUM+1

						!Compute the surface node properties
						IF (SOLIDSUM==0) THEN
							WEIGHT(CUR)=0.75
							SURFWEIGHT(CUR)=1.0
						ELSEIF (SOLIDSUM==1) THEN
							WEIGHT(CUR)=0.5
							SURFWEIGHT(CUR)=1.0
						ELSEIF (SOLIDSUM==2) THEN
							WEIGHT(CUR)=0.25
							SURFWEIGHT(CUR)=1.0
						ELSE
							PRINT *, 'ASSIGN_NODES> CASE NOT DEFINED AT NODE', CUR, 'J1, J2, J3 =',J1,J2,J3, 'SOLIDSUM', SOLIDSUM
						ENDIF
		
					ENDIF
				ENDIF				



				!Compute the pair properties between neighbours
				IF (NODESTATE(CUR)==0) THEN
					IF (NODESTATE(CURXPY0Z0)==1) THEN
						PAIRSTATE(CUR,1)=2
					ELSE
						PAIRSTATE(CUR,1)=1
					ENDIF

					IF (NODESTATE(CURXMY0Z0)==1) THEN
						PAIRSTATE(CUR,2)=2
					ELSE
						PAIRSTATE(CUR,2)=1
					ENDIF

					IF (NODESTATE(CURX0YPZ0)==1) THEN
						PAIRSTATE(CUR,3)=2
					ELSE
						PAIRSTATE(CUR,3)=1
					ENDIF
			
					IF (NODESTATE(CURX0YMZ0)==1) THEN
						PAIRSTATE(CUR,4)=2
					ELSE
						PAIRSTATE(CUR,4)=1
					ENDIF

					IF (NODESTATE(CURX0Y0ZP)==1) THEN
						PAIRSTATE(CUR,5)=2
					ELSE
						PAIRSTATE(CUR,5)=1
					ENDIF

					IF (NODESTATE(CURX0Y0ZM)==1) THEN
						PAIRSTATE(CUR,6)=2
					ELSE
						PAIRSTATE(CUR,6)=1
					ENDIF
				ELSEIF (NODESTATE(CUR)==1) THEN
					!Specific conditions for a neighboring surface normal facing back at the current node
					IF (WEIGHT(CURXPY0Z0)==0.125) THEN
						PAIRSTATE(CUR,1)=2
					ELSEIF ( (WEIGHT(CUR)==0.5) .AND. (WEIGHT(CURXPY0Z0)==0.25) ) THEN
						PAIRSTATE(CUR,1)=2
					ELSEIF ( (WEIGHT(CUR)==0.75) .AND. (WEIGHT(CURXPY0Z0)==0.375) ) THEN
						PAIRSTATE(CUR,1)=2
					ELSE
						!Not a corner
						PAIRSTATE(CUR,1)=1
					ENDIF

					IF (WEIGHT(CURXMY0Z0)==0.125) THEN
						PAIRSTATE(CUR,2)=2
					ELSEIF ( (WEIGHT(CUR)==0.5) .AND. (WEIGHT(CURXMY0Z0)==0.25) ) THEN
						PAIRSTATE(CUR,2)=2
					ELSEIF ( (WEIGHT(CUR)==0.75) .AND. (WEIGHT(CURXMY0Z0)==0.375) ) THEN
						PAIRSTATE(CUR,2)=2
					ELSE
						PAIRSTATE(CUR,2)=1
					ENDIF

					IF (WEIGHT(CURX0YPZ0)==0.125) THEN
						PAIRSTATE(CUR,3)=2
					ELSEIF ( (WEIGHT(CUR)==0.5) .AND. (WEIGHT(CURX0YPZ0)==0.25) ) THEN
						PAIRSTATE(CUR,3)=2
					ELSEIF ( (WEIGHT(CUR)==0.75) .AND. (WEIGHT(CURX0YPZ0)==0.375) ) THEN
						PAIRSTATE(CUR,3)=2
					ELSE
						PAIRSTATE(CUR,3)=1
					ENDIF

					IF (WEIGHT(CURX0YMZ0)==0.125) THEN
						PAIRSTATE(CUR,4)=2
					ELSEIF ( (WEIGHT(CUR)==0.5) .AND. (WEIGHT(CURX0YMZ0)==0.25) ) THEN
						PAIRSTATE(CUR,4)=2
					ELSEIF ( (WEIGHT(CUR)==0.75) .AND. (WEIGHT(CURX0YMZ0)==0.375) ) THEN
						PAIRSTATE(CUR,4)=2
					ELSE
						PAIRSTATE(CUR,4)=1
					ENDIF

					IF (WEIGHT(CURX0Y0ZP)==0.125) THEN
						PAIRSTATE(CUR,5)=4
					ELSEIF ( (WEIGHT(CUR)==0.5) .AND. (WEIGHT(CURX0Y0ZP)==0.25) ) THEN
						PAIRSTATE(CUR,5)=4
					ELSEIF ( (WEIGHT(CUR)==0.75) .AND. (WEIGHT(CURX0Y0ZP)==0.375) ) THEN
						PAIRSTATE(CUR,5)=4
					ELSE
						PAIRSTATE(CUR,5)=3
					ENDIF

					IF (WEIGHT(CURX0Y0ZM)==0.125) THEN
						PAIRSTATE(CUR,6)=2
					ELSEIF ( (WEIGHT(CUR)==0.5) .AND. (WEIGHT(CURX0Y0ZM)==0.25) ) THEN
						PAIRSTATE(CUR,6)=2
					ELSEIF ( (WEIGHT(CUR)==0.75) .AND. (WEIGHT(CURX0Y0ZM)==0.375) ) THEN
						PAIRSTATE(CUR,6)=2
					ELSE
						PAIRSTATE(CUR,6)=1
					ENDIF

				ENDIF



				!Fill the GSQCASE array
				IF (NODESTATE(CUR)==0) THEN
					GSQCASE(CUR,:)=0.0
				ELSEIF (NODESTATE(CUR)==1) THEN
					IF ( (NODESTATE(CURXPY0Z0)>=0) .AND. (NODESTATE(CURXMY0Z0)>=0) ) THEN
						GSQCASE(CUR,1)=0
					ELSEIF (NODESTATE(CURXPY0Z0)==-1) THEN
						GSQCASE(CUR,1)=-1
					ELSEIF (NODESTATE(CURXMY0Z0)==-1) THEN
						GSQCASE(CUR,1)=1
					ENDIF

					IF ( (NODESTATE(CURX0YPZ0)>=0) .AND. (NODESTATE(CURX0YMZ0)>=0) ) THEN
						GSQCASE(CUR,2)=0
					ELSEIF (NODESTATE(CURX0YPZ0)==-1) THEN
						GSQCASE(CUR,2)=-1
					ELSEIF (NODESTATE(CURX0YMZ0)==-1) THEN
						GSQCASE(CUR,2)=1
					ENDIF

					IF ( (NODESTATE(CURX0Y0ZP)>=0) .AND. (NODESTATE(CURX0Y0ZM)>=0) ) THEN
						GSQCASE(CUR,3)=0
					ELSEIF (NODESTATE(CURX0Y0ZP)==-1) THEN
						GSQCASE(CUR,3)=-1
					ELSEIF (NODESTATE(CURX0Y0ZM)==-1) THEN
						GSQCASE(CUR,3)=1
					ENDIF
				ENDIF
					


			ENDIF
			
			 

		
		ENDDO
	ENDDO
ENDDO
ENDDO


!Debug: Output node arrays

OPEN(1,FILE='nodestate.out')
WRITE(1,'(1I10)') NODESTATE
CLOSE(1)

OPEN(1,FILE='neighbs.out')
DO CUR=1,N_NODES
	WRITE(1,'(6I10)') NEIGHBS(CUR,:)
ENDDO
CLOSE(1)

OPEN(1,FILE='weight.out')
WRITE(1,'(F20.10)') WEIGHT
CLOSE(1)

OPEN(1,FILE='surfweight.out')
WRITE(1,'(F20.10)') SURFWEIGHT
CLOSE(1)

OPEN(1,FILE='pairstate.out')
DO CUR=1,N_NODES
	WRITE(1,'(6I10)') PAIRSTATE(CUR,:)
ENDDO
CLOSE(1)

OPEN(1,FILE='gsqcase.out')
DO CUR=1,N_NODES
	WRITE(1,'(3I10)') GSQCASE(CUR,:)
ENDDO
CLOSE(1)



END SUBROUTINE ASSIGN_NODES
!---------------------------------------------------------------------------------------------







!---------------------------------------------------------------------------------------------------------------
!Test the gradient vs a finite difference approximation
SUBROUTINE TEST_GRADIENT(V)
IMPLICIT NONE
INTEGER :: CUR,J4
DOUBLE PRECISION :: DT, A_0, A_P, A_M, E_P, E_M, TEST_GRAD(N), GRAD_DIFF(N), V(N)

DT=0.00001

DO CUR=1,N_NODES
	DO J4=1,N_PHASE
		
		A_0 = COORDSG(CUR,J4)
		A_P = COORDSG(CUR,J4) + DT
		A_M = COORDSG(CUR,J4) - DT

		E=0.0

		COORDSG(CUR,J4) = A_P
		CALL COMPUTE_ENERGY(E)
		E_P=E

		COORDSG(CUR,J4)=A_M
		CALL COMPUTE_ENERGY(E)
		E_M=E

		TEST_GRAD((CUR-1)*N_PHASE+J4) = (E_P-E_M)/(2*DT)

		COORDSG(CUR,J4) = A_0

	
		PRINT *, V((CUR-1)*N_PHASE+J4), TEST_GRAD((CUR-1)*N_PHASE+J4), V((CUR-1)*N_PHASE+J4)-TEST_GRAD((CUR-1)*N_PHASE+J4)
		IF (ABS(V((CUR-1)*N_PHASE+J4)-TEST_GRAD((CUR-1)*N_PHASE+J4))>=0.5) THEN
			PRINT *, 'STOP AT', CUR, J4
			PRINT *, E_P, E_M
		 	 STOP
		ENDIF

	ENDDO

ENDDO

GRAD_DIFF = V-TEST_GRAD
PRINT *, SUM(SQRT(GRAD_DIFF*GRAD_DIFF))

!stop

OPEN(1,FILE='grad.diff')
WRITE(1,'(F20.10)') GRAD_DIFF
CLOSE(1)

OPEN(1,FILE='grad.orig')
WRITE(1,'(F20.10)') G
CLOSE(1)

OPEN(1,FILE='grad.test')
WRITE(1,'(F20.10)') TEST_GRAD
CLOSE(1)

!STOP

END SUBROUTINE TEST_GRADIENT


END MODULE potential
